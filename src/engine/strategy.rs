use std::sync::Arc;

use log::{error, info};
use tokio::sync::{
    broadcast::{self, error::RecvError},
    mpsc,
};
use tokio_util::sync::CancellationToken;

use crate::{engine::EngineContext, exchange::LiveData};

/// Trading Signal.
///
/// Trading signals are used to indicate the action a strategy executor or trading
/// engine should take. Signals are generated by a particular strategy.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SignalType {
    Buy,
    Hold,
    Sell,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Signal {
    pub symbol: String,
    pub signal_type: SignalType,
}

/// Trait encapsulating the core logic of a trading strategy.
pub trait Strategy {
    /// Process a market update.
    ///
    /// This method should be implemented by concrete strategy implementations to process incoming market data and generate trading signals.
    fn process(&self, data: &LiveData) -> Signal;
}

/// A metric relating to an asset.
///
/// Indicators are useful for analyzing market trends and making informed trading decisions. Indicators
/// are used to generate trading signals and are an integral part of trading strategies.
pub trait Indicator {
    type Input;
    type Output;

    /// Updates the current value of the indicator
    fn update(&mut self, input: Self::Input);

    /// Retrieves the current value of the indicator
    fn value(&self) -> Self::Output;
}

/// Layer Responsible for the processing of live data.
///
/// The data processor should ingest live data as it comes in, calculate indicators needed for a strategy
pub struct StrategyExecutor<S: Strategy> {
    exchange_rx: broadcast::Receiver<LiveData>,
    order_tx: mpsc::Sender<Signal>,
    strategy: S,
    cancel: CancellationToken,
}

impl<S: Strategy> StrategyExecutor<S> {
    pub fn new(ctx: Arc<EngineContext>, order_tx: mpsc::Sender<Signal>, strategy: S) -> Self {
        // TODO: Use parsed settings for initial strategies but init it with a basic strategy

        StrategyExecutor {
            exchange_rx: ctx.receiver(),
            order_tx,
            strategy,
            cancel: ctx.cancel_token(),
        }
    }

    pub async fn start(&mut self) {
        info!("Starting StrategyExecutor");
        loop {
            tokio::select! {
                exchange_event = self.exchange_rx.recv() => {
                    self.on_exchange_event(exchange_event).await;
                }
                _ = self.cancel.cancelled() => {
                    break;
                }
            }
        }

        info!("StrategyExecutor exited successfully.");
    }

    async fn on_exchange_event(&mut self, event: Result<LiveData, RecvError>) {
        match event {
            Ok(data) => {
                info!("Received Live Data: {:?}", data);
                let signal = self.strategy.process(&data);
                if signal.signal_type != SignalType::Hold {
                    let _ = self.order_tx.send(signal).await;
                }
            }
            Err(err) => {
                error!("{}", err);
            }
        };
    }
}
