use crate::broker::data::BrokerData;

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Signal {
    symbol: String,
    direction: SignalDirection,
}

impl Signal {
    pub fn new(symbol: String, direction: SignalDirection) -> Self {
        Signal { symbol, direction }
    }

    pub fn symbol(&self) -> &str {
        &self.symbol
    }

    pub fn direction(&self) -> SignalDirection {
        self.direction
    }
}

/// Trading Signal.
///
/// Trading signals are used to indicate the action a strategy executor or trading
/// engine should take. Signals are generated by a particular strategy.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SignalDirection {
    Buy,
    Neutral,
    Sell,
}

/// Trait encapsulating the core logic of a trading strategy.
pub trait Strategy {
    /// Process a market update.
    ///
    /// This method should be implemented by concrete strategy implementations to process incoming market data and generate trading signals.
    fn process(&self, data: &BrokerData) -> Signal;
}

/// A metric relating to an asset.
///
/// Indicators are useful for analyzing market trends and making informed trading decisions. Indicators
/// are used to generate trading signals and are an integral part of trading strategies.
pub trait Indicator {
    type Input;
    type Output;

    /// Updates the current value of the indicator
    fn update(&mut self, input: Self::Input);

    /// Retrieves the current value of the indicator
    fn value(&self) -> Self::Output;
}

/// Layer Responsible for the processing of live data.
///
/// The data processor should ingest live data as it comes in, calculate indicators needed for a strategy
pub struct StrategyExecutor<S: Strategy> {
    strategy: S,
}

impl<S: Strategy> StrategyExecutor<S> {
    pub fn new(strategy: S) -> Self {
        StrategyExecutor { strategy }
    }

    pub async fn evaluate_strategies(&self, data: BrokerData) -> Signal {
        // Will become more complex as the executor evolves to handle multiple strategies and indicators
        self.strategy.process(&data)
    }
}
